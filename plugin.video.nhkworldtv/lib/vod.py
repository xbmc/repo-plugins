from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import re
from kodi_six import xbmc, xbmcaddon
from . import utils, cache_api, kodiutils, url, nhk_api
from .episode import Episode

episode_cache = None
ADDON = xbmcaddon.Addon()

if (ADDON.getSettingBool('use_backend')):
    xbmc.log('vod.py: Loading episode cache from Azure')
    # Define how many program should be retrieved from meta data cache
    cache_items = ADDON.getSettingInt("max_program_metadate_cache_items")
    # Try to get the meta dara cache from Azure
    # Under unit test, cache_items will be 0
    # So an empty cache will be retrieved
    episode_cache = cache_api.get_program_metdadata_cache(cache_items)

    # Only use it if we got valid dict back
    # Also means that the service is running and we can use it
    if (isinstance(episode_cache, dict)):
        USE_CACHE = True
        xbmc.log('vod.py: Using program metadata cache from Azure')

if (utils.UNIT_TEST):
    # Run under unit test - set some default data since we will not
    # be able to retrieve data from settings.xml

    # Always enable meta data cache for testing
    episode_cache = cache_api.get_program_metdadata_cache(2000)


def get_episode_list(api_method, id, show_only_subtitle):
    """  Video On Demand - Episode List

        Returns episode list based on the requested NHK API Method
        (e.g. Programs, Categories, etc.)

    Args:
        api_method ([str]): The NHK API method to use
        id ([str]): ID to use (optional)
        show_only_subtitle ([bool]): Only show subtitles
    Returns:
        [list] -- List of episodes
    """

    # Only format api_url when a non-0 value for id was provided
    # some APIs do not need an id
    if (id != 'None'):
        api_url = nhk_api.rest_url[api_method].format(id)
    else:
        api_url = nhk_api.rest_url[api_method]

    api_result_json = url.get_json(api_url)['data']

    if ('episodes' in api_result_json):
        # "Normal" episode list
        program_json = api_result_json['episodes']
    elif ('playlist' in api_result_json):
        # Episode List that is generated by the PlayList API
        program_json = api_result_json['playlist'][0]['track']
    else:
        # Unknown source, abort
        return None

    episodes = []
    episode = None
    for row in program_json:
        episode = Episode()
        episode.is_playable = True
        title = row['title_clean']
        subtitle = row['sub_title_clean']

        if int(show_only_subtitle) == 1:
            # Show only subtitle
            if len(subtitle) > 0:
                # There is a subtitle, use it
                episode_name = subtitle
            else:
                # Use the title instead of the subtitle
                episode_name = title
        else:
            # Show complete title
            if len(title) == 0:
                # Use the subtitle as the episode name
                # because there is no title
                episode_name = subtitle
            else:
                # Use the full episode name
                episode_name = utils.get_episode_name(title, subtitle)

        episode.title = episode_name
        description = row['description_clean']
        episode.thumb = row['image']
        episode.fanart = row['image_l']
        episode.vod_id = row['vod_id']
        episode.pgm_no = row['pgm_no']
        episode.duration = row['movie_duration']

        # Check if we have an aired date
        broadcast_start_timestamp = row['onair']

        if (broadcast_start_timestamp is not None):
            episode.broadcast_start_date = broadcast_start_timestamp
            episode.broadcast_end_date = row['vod_to']
            episode.plot_include_broadcast_detail = True

        episode.plot = description
        episodes.append(episode)
    return (episodes)


def get_episode_from_cache(episode, use_720p=False):
    """ Add a Kodi directory item for a playable episode

    Args:
        episode ([Episode]): The episode
        use_720p ([boolean], optional): Use 720P or 1080p.
        Defaults to USE_720P from add-on settings

    Returns:
        [type]: [description]
    """
    # If the vod_id is in cache and cache is being used,
    # directly add the URL otherwise dynamically resolve it
    # via play_vod_episode()
    #
    # Use the cache backend or not
    return_value = None
    if (episode.vod_id in episode_cache):
        cached_episode = episode_cache[episode.vod_id]
        # In cache - display directly
        # If we should use 720P or there is no 1080P file, use 720P
        if ((use_720p) or (cached_episode['P1080P'] is None)):
            episode.url = cache_api.base_url + cached_episode['P720P']
            episode.video_info = kodiutils.get_video_info(use_720p=True)
        else:
            episode.url = cache_api.base_url + cached_episode['P1080P']
            episode.video_info = kodiutils.get_video_info(use_720p=False)
        episode.onair = cached_episode['OnAir']

        return_value = [episode.url, episode.kodi_list_item, False]
        xbmc.log(
            "vod.get_episode_from_cache: Added episode {0} from cache".format(
                episode.vod_id))
    return return_value


def resolve_vod_episode(vod_id, use_720p):
    """ Resolve a VOD episode directly from NHK

    Args:
        vod_id ([str]): The VOD Id
        use_720p ([boolean]): Use 720P or 1080p.
        Defaults to USE_720P from add-on settings

    Returns:
        [Episode]: The resolved Episode - only used for unit testing
    """

    episode = None
    xbmc.log(
        'vod.resolve_vod_episode: Using Player.js to retrieve vod_id: {0}'.
        format(vod_id))
    r = url.get_url(nhk_api.rest_url['player_url'].format(vod_id, vod_id))
    if (r.status_code == 200):
        # Player content retrieved
        player_js = r.text
        # Parse the output of the Player JS file for the UUID of the episode
        uuid_match = re.compile("'data-de-program-uuid','(.+?)'").findall(
            player_js)

        # Only continue if we could retrieve the uuid
        if (len(uuid_match) > 0):
            program_uuid = uuid_match[0]
            xbmc.log('vod.resolve_vod_episode: Parsed UUID: {0}'.format(
                program_uuid))
            # Get episode detail
            episode_detail = url.get_json(
                nhk_api.rest_url['get_episode_detail'].format(
                    vod_id))['data']['episodes'][0]
            if (r.status_code == 200):
                # Fill the episode details
                episode = Episode()
                episode.vod_id = vod_id
                episode.title = episode_detail['title_clean']
                episode.broadcast_start_date = episode_detail['onair']
                episode.plot = episode_detail['description_clean']
                episode.pgm_no = episode_detail['pgm_no']
                episode.duration = episode_detail['movie_duration']

                # Get episode URL and video information
                player_url = nhk_api.rest_url['video_url'].format(program_uuid)
                xbmc.log('vod.resolve_vod_episode: Player Url: {0}'.format(
                    player_url))

                assets_json = url.get_json(player_url)['response'][
                    'WsProgramResponse']['program']['asset']

                if (isinstance(assets_json, dict)):
                    # Valid JSON
                    # Get the reference file (HD)
                    reference_file_json = assets_json['referenceFile']
                    play_path = reference_file_json['rtmp']['play_path'].split(
                        '?')[0]

                    # Only add the reference URL if exists
                    reference_url = nhk_api.rest_url['episode_url'].format(
                        play_path)
                    if ((url.check_url_exists(reference_url) is True)
                            and not use_720p):
                        episode.url = nhk_api.rest_url['episode_url'].format(
                            play_path)
                        episode.video_info = kodiutils.get_video_info(
                            use_720p=False)
                        episode.is_playable = True
                    else:
                        # Prefer 720P or video doesn't have a reference file.
                        # Then use the 720P Version instead
                        # Asset #0 is the 720P Version
                        asset = assets_json['assetFiles'][0]
                        play_path = asset['rtmp']['play_path'].split('?')[0]
                        episode.url = nhk_api.rest_url['episode_url'].format(
                            play_path)
                        episode.video_info = kodiutils.get_video_info(
                            use_720p=True)
                        episode.is_playable = True

    return (episode)
